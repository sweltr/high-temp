---
title: "4b Filtering: PERFect (PERmutation Filtering test for microbiome data)"
description: |
  Reproducible workflow for ... In this workflow, ....
author:
#  - name: Jarrod J Scott
#    url: https://example.com/norajones
#    affiliation: Spacely Sprockets
#    affiliation_nrl: https://example.com/spacelysprokets
bibliography: assets/cite.bib
---

<details markdown="1">
<summary>Click here for setup information.</summary>

```{r setup}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
set.seed(119)
#library(conflicted)

#pacman::p_depends(gdata, local = TRUE)  
#pacman::p_depends_reverse(gdata, local = TRUE)  
library(phyloseq); packageVersion("phyloseq")
library(Biostrings); packageVersion("Biostrings")
pacman::p_load(tidyverse, codefolder, microbiome, DT, 
               patchwork, ampvis2, labdsv, PERFect, ape, gdata,
               install = FALSE, update = FALSE)

options(scipen=999)
knitr::opts_current$get(c(
  "cache",
  "cache.path",
  "cache.rebuild",
  "dependson",
  "autodep"
))
```

</details> 

In this workflow, we used PERFect [(PERmutation Filtering test for microbiome data)](https://github.com/katiasmirn/PERFect) [@smirnova2019perfect] to filter the FULL 16S rRNA (ASV & OTU) and ITS (ASV & OTU) data sets. 

The first step in the PERFect process is to rarefy the data and then proceed with the filtering. Here is a summary of the results. Tables show comparisons of ASV vs. OTU data sets. Tables are duplicated in the relevant sections below.

## 16S rRNA ASV vs. OTU

```{r, include=FALSE, eval=TRUE}
## Load to build page only #3
remove(list = ls())
load("page_build/perfect_ssu18_wf.rdata")
load("page_build/perfect_its18_wf.rdata")
objects()
gdata::keep(ssu18_perfect_sum, its18_perfect_sum, sure = TRUE)
```

```{r, echo=FALSE, layout="l-body", eval=TRUE}
knitr::kable(ssu18_perfect_sum)
```

## ITS ASV vs. OTU

```{r, echo=FALSE, layout="l-body", eval=TRUE}
knitr::kable(its18_perfect_sum)
```

# Prerequisites

This workflow contains PERFect filtering the 2018 data sets. In order to run the workflow, you either need to first run the  [DADA2 Workflow](dada2.html), the [Data Preparation workflow](data-prep.html), and the [OTU clustering workflow](otu.html). See the [Data Availability](data-availability.html) page for complete details.

# 16s rRNA Data Set

```{r, include=FALSE, eval=TRUE}
## Load to build page only #3
remove(list = ls())
load("page_build/perfect_ssu18_wf.rdata")
```

```{r, include=FALSE}
## Initial Load for PERFect  ANALYSIS #1
remove(list = ls())
set.seed(119)
ssu18_ps_work <- readRDS("files/data-prep/rdata/ssu18_ps_work.rds")
ssu18_ps_work_otu <- readRDS("files/otu/rdata/ssu18_ps_work_otu.rds")
```

## Setup

To run PERFect, we need the ASV/OTU tables in data frame format with samples as rows and ASVs/OTUs as columns. PERFect is sensitive to the order of ASVs/OTUs, so here we test a) the default order in the phyloseq object and b) ASVs/OTUs ordered by decreasing abundance.

```{r, code_folding=TRUE}
samp_ps_filt <- c("ssu18_ps_work", "ssu18_ps_work_otu")
for (i in samp_ps_filt) {
  tmp_get <- get(i)
  tmp_get_tab <- data.frame(t(otu_table(tmp_get)))
  tmp_get_tab <- tmp_get_tab %>% tibble::rownames_to_column("ID")
  tmp_get_tab <- jamba::mixedSortDF(tmp_get_tab, decreasing = FALSE, 
                                        useRownames = FALSE, byCols = 1)
  tmp_get_tab <- tmp_get_tab %>% tibble::remove_rownames() 
  tmp_get_tab <- tmp_get_tab %>% tibble::column_to_rownames("ID")
  tmp_get_tab <- data.frame(t(tmp_get_tab))

  tmp_get_tab_ord <- data.frame(t(otu_table(tmp_get)))
  tmp_get_tab_ord <- tmp_get_tab_ord %>% tibble::rownames_to_column("ID")
  tmp_get_tab_ord <- jamba::mixedSortDF(tmp_get_tab_ord, decreasing = TRUE, 
                                        useRownames = FALSE, byCols = 1)
  tmp_get_tab_ord <- tmp_get_tab_ord %>% tibble::remove_rownames() 
  tmp_get_tab_ord <- tmp_get_tab_ord %>% tibble::column_to_rownames("ID")
  tmp_get_tab_ord <- data.frame(t(tmp_get_tab_ord))

  tmp_tab_name <- purrr::map_chr(i, ~ paste0(., "_perfect"))
  assign(tmp_tab_name, tmp_get_tab)
  
  tmp_tab_ord_name <- purrr::map_chr(i, ~ paste0(., "_ord_perfect"))
  assign(tmp_tab_ord_name, tmp_get_tab_ord)
  
  rm(list = ls(pattern = "tmp_"))
}
objects()
```

## Filter 

Next we run the filtering analysis using [`PERFect_sim`](https://rdrr.io/github/katiasmirn/PERFect/man/PERFect_sim.html). The other option is [`PERFect_perm`](https://rdrr.io/github/katiasmirn/PERFect/man/PERFect_perm.html) however I could not get this to work as of this writing. The process never finished :/

```{r}
# Set a pvalue cutoff
per_pval <- 0.05
```


```{r, code_folding=TRUE}
for (i in samp_ps_filt) {
  tmp_get <- get(purrr::map_chr(i, ~ paste0(., "_perfect")))
  tmp_get_ord <- get(purrr::map_chr(i, ~ paste0(., "_ord_perfect")))
  tmp_sim <- PERFect_sim(X = tmp_get, alpha = per_pval, Order = "NP", center = FALSE)
  dim(tmp_sim$filtX)
  tmp_sim_ord <- PERFect_sim(X = tmp_get_ord, alpha = per_pval, Order = "NP", center = FALSE)
  dim(tmp_sim_ord$filtX)
  
  tmp_sim_name <- purrr::map_chr(i, ~ paste0(., "_perfect_sim"))
  assign(tmp_sim_name, tmp_sim)

  tmp_sim_ord_name <- purrr::map_chr(i, ~ paste0(., "_ord_perfect_sim"))
  assign(tmp_sim_ord_name, tmp_sim_ord)
  
  tmp_path <- file.path("files/perfect/rdata/")
  saveRDS(tmp_sim, paste(tmp_path, tmp_sim_name, ".rds", sep = ""))
  saveRDS(tmp_sim_ord, paste(tmp_path, tmp_sim_ord_name, ".rds", sep = ""))

  rm(list = ls(pattern = "tmp_"))
  
}
objects(pattern = "_sim")
```

```{r, echo=FALSE}
## FOR TESTING
dim(ssu18_ps_work_perfect_sim$filtX)
dim(ssu18_ps_work_ord_perfect_sim$filtX)
dim(ssu18_ps_work_otu_perfect_sim$filtX)
dim(ssu18_ps_work_otu_ord_perfect_sim$filtX)

###########
tmp_obj <- ssu18_ps_work_otu_ord_perfect_sim
tmp_ps <- ssu18_ps_work_otu
###########
tmp_filt <- data.frame(t(tmp_obj$filtX))
tmp_filt <- tmp_filt %>% tibble::rownames_to_column("ID")
tmp_pval <- data.frame(tmp_obj$pvals)
tmp_pval <- tmp_pval %>% tibble::rownames_to_column("ID")
tmp_org <- data.frame(t(otu_table(tmp_ps)))
tmp_org <- tmp_org %>% tibble::rownames_to_column("ID")
tmp_com <- dplyr::left_join(tmp_pval, tmp_org, by = "ID") %>%
           dplyr::left_join(., tmp_filt, by = "ID")
write.table(tmp_com, "tmp_com.txt", quote = FALSE, sep = "\t", row.names = FALSE)
```

```{r, echo=FALSE}
ps_sim <- c("ssu18_ps_work_perfect_sim", "ssu18_ps_work_ord_perfect_sim", 
            "ssu18_ps_work_otu_perfect_sim", "ssu18_ps_work_otu_ord_perfect_sim")
for (i in ps_sim) {
  tmp_get <- get(i)
  tmp_name <- i
  tmp_get$info <- NULL
  tmp_get$DFL <- NULL
  tmp_get$est <- NULL
  tmp_get$fit <- NULL
  tmp_get$hist <- NULL
  tmp_get$pDFL <- NULL
  assign(tmp_name, tmp_get)
  rm(list = ls(pattern = "tmp_"))
}  
objects()
```

Now let's take a look at how many ASVs/OTUs were retained. 

First the ASV data set. Default ordering resulted in 
**`r dim(ssu18_ps_work_perfect_sim$filtX)[2]`** ASVs 
and reordering the data resulted in 
**`r dim(ssu18_ps_work_ord_perfect_sim$filtX)[2]`** ASVs.

And the OTU data set. Default ordering resulted in 
**`r dim(ssu18_ps_work_otu_perfect_sim$filtX)[2]`** OTUs 
and reordering the data resulted in 
**`r dim(ssu18_ps_work_otu_ord_perfect_sim$filtX)[2]`** OTUs.

For some reason, the package does not remove based on the p value cutoff that we set earlier (`0.05`). So we need to filter out the ASVs/OTUs that have a higher p value than the cutoff.

```{r echo=FALSE, results='hold', eval=TRUE}
cat("Total ASVs with p value less than", per_pval[1], "\n")
tmp_df <- ssu18_ps_work_perfect_sim$pvals
tmp_df <- data.frame(tmp_df)
pval_asv <- tmp_df %>% dplyr::summarise(count = sum(tmp_df <= per_pval))
print(paste("default order: ASVs before checking p value was", dim(ssu18_ps_work_perfect_sim$filtX)[2], "and after was", pval_asv$count[1]))

tmp_df <- ssu18_ps_work_ord_perfect_sim$pvals
tmp_df <- data.frame(tmp_df)
pval_asv_ord <- tmp_df %>% dplyr::summarise(count = sum(tmp_df <= per_pval))
print(paste("decreasing order: ASVs before checking p value was", dim(ssu18_ps_work_ord_perfect_sim$filtX)[2], "and after was", pval_asv_ord$count[1]))

print("-------------------")

cat("Total OTUs with p value less than", per_pval[1], "\n")
tmp_df <- ssu18_ps_work_otu_perfect_sim$pvals
tmp_df <- data.frame(tmp_df)
pval_otu <- tmp_df %>% dplyr::summarise(count = sum(tmp_df <= per_pval))
print(paste("default order: OTUs before checking p value was", dim(ssu18_ps_work_otu_perfect_sim$filtX)[2], "and after was", pval_otu$count[1]))
############
tmp_df <- ssu18_ps_work_otu_ord_perfect_sim$pvals
tmp_df <- data.frame(tmp_df)
pval_otu_ord <- tmp_df %>% dplyr::summarise(count = sum(tmp_df <= per_pval))
print(paste("decreasing order: OTUs before checking p value was", dim(ssu18_ps_work_otu_ord_perfect_sim$filtX)[2], "and after was", pval_otu_ord$count[1]))
```

Now we can make phyloseq objects. Manual inspection of the results from `PERFect_sim` indicated that using the decrease order and filtering p values < 0.05 resulted in the best results. This approach limited the number of ASVs/OTUs found in only 1 or 2 samples.

So first we filter out ASVs/OTUs with p values < 0.05 and then make the objects.

```{r, code_folding=TRUE}
for (i in samp_ps_filt) {
    tmp_get <- get(purrr::map_chr(i, ~ paste0(., "_ord_perfect")))
    tmp_get_sim <- get(purrr::map_chr(i, ~ paste0(., "_ord_perfect_sim")))
    tmp_filt <- data.frame(t(tmp_get_sim$filtX))
    tmp_filt <- tmp_filt %>% tibble::rownames_to_column("ID")
    tmp_tab <- data.frame(t(tmp_get))
    tmp_tab <- tmp_tab %>% tibble::rownames_to_column("ID")
    tmp_pvals <- data.frame(tmp_get_sim$pvals)
    tmp_pvals <- tmp_pvals %>% tibble::rownames_to_column("ID") %>% 
              dplyr::rename("pval" = 2)
    tmp_pvals <- tmp_pvals %>% filter(pval <= 0.05)
    tmp_merge <- dplyr::left_join(tmp_pvals, tmp_tab, by = "ID")
    tmp_merge[, 2] <- NULL
    tmp_merge <- tmp_merge %>% tibble::column_to_rownames("ID")
    tmp_tax <- data.frame(tax_table(get(i))) %>% tibble::rownames_to_column("ID")
    tmp_tax <- dplyr::left_join(tmp_pvals, tmp_tax, by = "ID")
    tmp_tax[, 2] <- NULL
    tmp_tax <- tmp_tax %>% tibble::column_to_rownames("ID")
# Build PS object
    tmp_samp <- data.frame(sample_data(get(i)))
    identical(row.names(tmp_tax), row.names(tmp_merge))
    tmp_merge <- data.frame(t(tmp_merge))
    tmp_merge <- as.matrix(tmp_merge)
    tmp_tax <- as.matrix(tmp_tax)
    tmp_ps <- phyloseq(otu_table(tmp_merge, taxa_are_rows = FALSE),
                     tax_table(tmp_tax),
                     sample_data(tmp_samp))
    
    tmp_tree <- rtree(ntaxa(tmp_ps), rooted = TRUE,
                           tip.label = taxa_names(tmp_ps))
    tmp_ps <- merge_phyloseq(tmp_ps,
                               sample_data,
                               tmp_tree)
    tmp_ps_name <- purrr::map_chr(i, ~ paste0(., "_perf_filt"))
    assign(tmp_ps_name, tmp_ps)
    rm(list = ls(pattern = "tmp_"))
}  
objects()
objects(pattern = "_filt")
```

```{r, eval=TRUE, echo=FALSE}
print("ASV phyloseq object")
ssu18_ps_work_perf_filt
print("OTU phyloseq object")
ssu18_ps_work_otu_perf_filt
```

Now let's take a look at how many reads and ASVs/OTUs were removed.

```{r, echo=FALSE}
# TO subset each TEMP
sample_data(ssu18_ps_work)
ps_samples <- c("ssu18_ps_work", "ssu18_ps_work_perf_filt", 
                 "ssu18_ps_work_otu", "ssu18_ps_work_otu_perf_filt")
select_temp <- c("0", "3", "8")
rm(i)
for (j in select_temp) {
  for (i in ps_samples) {
     tmp_get <- get(i)
     tmp_df <- data.frame(sample_data(tmp_get))
     tmp_keep <- row.names(dplyr::filter(tmp_df, TEMP == j))
     tmp_ps <- prune_samples(tmp_keep, tmp_get)
     tmp_ps
     tmp_ps_prune <- prune_taxa(taxa_sums(tmp_ps) > 0, tmp_ps)
     tmp_ps_prune
     tmp_ps_name <- purrr::map_chr(i, ~ paste0(., "_", j))
     assign(tmp_ps_name, tmp_ps_prune)
     rm(list = ls(pattern = "tmp_"))
  }
}  
objects()
ssu18_ps_work_perf_filt_3
```


```{r, echo=FALSE, eval=FALSE, warning=FALSE}
tmp_objects <- data.frame(c("FULL data set", "PERFect filtered data", 
                            "FULL data set", "PERFect filtered data"))
tmp_samples <- c("ssu18_ps_work", "ssu18_ps_work_perf_filt", 
                 "ssu18_ps_work_otu", "ssu18_ps_work_otu_perf_filt")
tmp_type <- c("ASV", "ASV", "OTU", "OTU")
tmp_no_samp <- c()
for (i in tmp_samples) {
   tmp_get <- nsamples(get(i))
   tmp_no_samp <- c(append(tmp_no_samp, tmp_get))
}
tmp_no_samp <- data.frame(tmp_no_samp)

tmp_rc <- c()
for (i in tmp_samples) {
   tmp_get <- sum(readcount(get(i)))
   tmp_rc <- c(append(tmp_rc, tmp_get))
}
tmp_rc <- data.frame(tmp_rc)

tmp_asv <- c()
for (i in tmp_samples) {
   tmp_get <- ntaxa(get(i))
   tmp_asv <- c(append(tmp_asv, tmp_get))
}
tmp_asv <- data.frame(tmp_asv)

ssu18_perfect_sum <- dplyr::bind_cols(tmp_objects, tmp_type) %>%
                         dplyr::bind_cols(., tmp_no_samp) %>%
                         dplyr::bind_cols(., tmp_rc) %>%
                         dplyr::bind_cols(., tmp_asv) %>%
  dplyr::rename("Description" = 1, "type" = 2, "no. samples" = 3,
                "total reads" = 4, "total asvs" = 5)
rm(list = ls(pattern = "tmp_"))
```

<br/>

```{r, echo=FALSE, layout="l-body", eval=TRUE}
knitr::kable(ssu18_perfect_sum)
```

</br>

And finally save the phyloseq PERfect objects.

```{r, code_folding=TRUE}
ssu18_ps_perfect <- ssu18_ps_work_perf_filt
saveRDS(ssu18_ps_perfect, "files/perfect/rdata/ssu18_ps_perfect.rds")
ssu18_ps_perfect_otu <- ssu18_ps_work_otu_perf_filt
saveRDS(ssu18_ps_perfect_otu, "files/perfect/rdata/ssu18_ps_perfect_otu.rds")
```

```{r, echo=FALSE}
ssu18_perf_preval.tax <- tax_table(ssu18_ps_perfect)
write.table(ssu18_perf_preval.tax,
            file="files/perfect/tables/ssu18_asv_PERFECT_tax_table.txt",
            sep = "\t", quote = FALSE)

ssu18_perf_preval.asv <- otu_table(t(ssu18_ps_perfect))
write.table(ssu18_perf_preval.asv,
            file="files/perfect/tables/ssu18_asv_PERFECT_otu_table.txt",
            sep = "\t", quote = FALSE)

ssu18_perf_preval.samp <- sample_data(ssu18_ps_perfect)
write.table(ssu18_perf_preval.samp,
            file="files/perfect/tables/ssu18_asv_PERFECT_sample_data.txt",
            sep = "\t", quote = FALSE)
```

## Create Ampvis2 PERfect Objects

```{r, code_folding=TRUE}
ps_filt_obj <- c("ssu18_ps_perfect", "ssu18_ps_perfect_otu")
for (i in ps_filt_obj) {
    tmp_get <- get(i)
    tmp_otu <- data.frame(t(otu_table(tmp_get)))
    tmp_otu[] <- lapply(tmp_otu, as.numeric)
    tmp_otu <- as.matrix(tmp_otu)
    tmp_tax <- as.matrix(data.frame(tax_table(tmp_get)))
    tmp_samples <- data.frame(sample_data(tmp_get))
    tmp_ps_amp <- merge_phyloseq(otu_table(tmp_otu, taxa_are_rows = TRUE),
                          tax_table(tmp_tax),
                          sample_data(tmp_samples), phy_tree(tmp_get))
    tmp_ps_name <- purrr::map_chr(i, ~ paste0(., "_prep"))
    assign(tmp_ps_name, tmp_ps_amp)
    rm(list = ls(pattern = "tmp_"))
}
objects(pattern = "_prep")
```

```{r, code_folding=TRUE}
for (i in ps_filt_obj) {
  tmp_ps <- get(purrr::map_chr(i, ~ paste0(., "_prep")))
  tmp_amp_asv  <- data.frame(otu_table(tmp_ps))
  tmp_amp_asv <- tmp_amp_asv %>% tibble::rownames_to_column("OTU")
  tmp_amp_tax  <- data.frame(tax_table(tmp_ps))
  tmp_amp_tax <- tmp_amp_tax %>% tibble::rownames_to_column("OTU")
  tmp_amp_tax[8:ncol(tmp_amp_tax)] <- NULL
  tmp_amp_tax$Species <- tmp_amp_tax$OTU
  tmp_amp_asv_tax_perfect <- left_join(tmp_amp_asv, tmp_amp_tax, by = "OTU")
  tmp_samp_data_t <- data.frame(sample_data(tmp_ps))
  tmp_amp_data_perfect <- amp_load(tmp_amp_asv_tax_perfect, metadata = tmp_samp_data_t, tree = phy_tree(tmp_ps))

  tmp_otu_tax_name <- purrr::map_chr(i, ~ paste0(., "_amp_otutax_tab"))
  assign(tmp_otu_tax_name, tmp_amp_asv_tax_perfect)

  tmp_ps_name <- purrr::map_chr(i, ~ paste0(., "_amp"))
  assign(tmp_ps_name, tmp_amp_data_perfect)
  rm(list = ls(pattern = "tmp_"))
}  
objects(pattern = "_amp")
objects()
```

## Summary

```{r, code_folding=TRUE}
tmp_diversity_perfect <- amp_alphadiv(ssu18_ps_perfect_amp,
                                     measure = "observed", richness = FALSE)

tmp_diversity_perfect <- tmp_diversity_perfect %>% 
  dplyr::rename("total_reads" = "Reads", "total_asvs" = "ObservedOTUs")

tmp_diversity_perfect <- tmp_diversity_perfect[order(tmp_diversity_perfect$SamName), ]
ssu18_ps_perfect_amp <- amp_load(ssu18_ps_perfect_amp_otutax_tab,
                          metadata = tmp_diversity_perfect, 
                          tree = phy_tree(ssu18_ps_perfect))
rm(tmp_diversity_perfect)

tmp_diversity_perfect <- amp_alphadiv(ssu18_ps_perfect_otu_amp, 
                                     measure = "observed", richness = FALSE)

tmp_diversity_perfect <- tmp_diversity_perfect %>% 
  dplyr::rename("total_reads" = "Reads", "total_asvs" = "ObservedOTUs")

tmp_diversity_perfect <- tmp_diversity_perfect[order(tmp_diversity_perfect$SamName), ]
ssu18_ps_perfect_otu_amp <- amp_load(ssu18_ps_perfect_otu_amp_otutax_tab,
                                     metadata = tmp_diversity_perfect, 
                                     tree = phy_tree(ssu18_ps_perfect_otu))
```


```{r, code_folding=TRUE}
ssu18_amp_perfect <- ssu18_ps_perfect_amp
rm(ssu18_ps_perfect_amp)
saveRDS(ssu18_amp_perfect, "files/perfect/rdata/ssu18_amp_perfect.rds")
ssu18_amp_perfect_otu <- ssu18_ps_perfect_otu_amp
rm(ssu18_ps_perfect_otu_amp)
saveRDS(ssu18_amp_perfect_otu, "files/perfect/rdata/ssu18_amp_perfect_otu.rds")
objects()
```

Let's take a look at a table of sample information. Any header with the `_p` suffix is the *PERfect filtered* data.

<br/>

```{r, echo=FALSE}
## This is for table only
ssu18_dummy_tab <- ssu18_amp_perfect$metadata
ssu18_dummy_tab <- ssu18_dummy_tab %>%
  dplyr::rename("total_reads_p" = "total_reads") %>%
  dplyr::rename("total_asvs_p" = "total_asvs")
```

```{r, echo=FALSE, layout="l-body-outset", eval=TRUE}
## elementId https://www.random.org/strings/
ssu18_samp_data_tab_2 <- ssu18_dummy_tab

datatable(ssu18_samp_data_tab_2, width = "100%", escape = FALSE,
          rownames = FALSE, filter = 'top',
          caption = htmltools::tags$caption(
            style = 'caption-side: bottom; text-align: left;',
            'Table: ', htmltools::em('Sample summary table.
            Use the buttons to navigate through the table or
            download a copy.')),
          elementId = "1a77o5c274wp84ttuu6d",
          extensions = 'Buttons', options = list(
            scrollX = TRUE,
            dom = 'Blfrtip',
            buttons = c('copy', 'csv', 'excel'),
            pageLength = 5,
            lengthMenu = c(5, 15)
            )
          ) %>%
    DT::formatStyle(columns = colnames(ssu18_samp_data_tab_2),
                    fontSize = '80%')
```


```{r, echo=FALSE}
save.image("page_build/perfect_ssu18_wf.rdata")
```

```{r include=FALSE, eval=TRUE}
gdata::keep(ssu18_perfect_sum, sure = TRUE)
```

# ITS Data Set

```{r, include=FALSE, eval=TRUE}
## Load to build page only #3
remove(list = ls())
load("page_build/perfect_its18_wf.rdata")
```

```{r, include=FALSE}
## Initial Load for PERFect  ANALYSIS #1
set.seed(119)
its18_ps_work <- readRDS("files/data-prep/rdata/its18_ps_work.rds")
its18_ps_work_otu <- readRDS("files/otu/rdata/its18_ps_work_otu.rds")
```

## Setup

To run PERFect, we need the ASV/OTU tables in data frame format with samples as rows and ASVs/OTUs as columns. PERFect is sensitive to the order of ASVs/OTUs, so here we test a) the default order in the phyloseq object and b) ASVs/OTUs ordered by decreasing abundance.

```{r, code_folding=TRUE}
samp_ps_filt <- c("its18_ps_work", "its18_ps_work_otu")
for (i in samp_ps_filt) {
  tmp_get <- get(i)
  tmp_get_tab <- data.frame(t(otu_table(tmp_get)))
  tmp_get_tab <- tmp_get_tab %>% tibble::rownames_to_column("ID")
  tmp_get_tab <- jamba::mixedSortDF(tmp_get_tab, decreasing = FALSE, 
                                        useRownames = FALSE, byCols = 1)
  tmp_get_tab <- tmp_get_tab %>% tibble::remove_rownames() 
  tmp_get_tab <- tmp_get_tab %>% tibble::column_to_rownames("ID")
  tmp_get_tab <- data.frame(t(tmp_get_tab))

  tmp_get_tab_ord <- data.frame(t(otu_table(tmp_get)))
  tmp_get_tab_ord <- tmp_get_tab_ord %>% tibble::rownames_to_column("ID")
  tmp_get_tab_ord <- jamba::mixedSortDF(tmp_get_tab_ord, decreasing = TRUE, 
                                        useRownames = FALSE, byCols = 1)
  tmp_get_tab_ord <- tmp_get_tab_ord %>% tibble::remove_rownames() 
  tmp_get_tab_ord <- tmp_get_tab_ord %>% tibble::column_to_rownames("ID")
  tmp_get_tab_ord <- data.frame(t(tmp_get_tab_ord))

  tmp_tab_name <- purrr::map_chr(i, ~ paste0(., "_perfect"))
  assign(tmp_tab_name, tmp_get_tab)
  
  tmp_tab_ord_name <- purrr::map_chr(i, ~ paste0(., "_ord_perfect"))
  assign(tmp_tab_ord_name, tmp_get_tab_ord)
  
  rm(list = ls(pattern = "tmp_"))
}
objects()
```

## Filter 

Next we run the filtering analysis using [`PERFect_sim`](https://rdrr.io/github/katiasmirn/PERFect/man/PERFect_sim.html). The other option is [`PERFect_perm`](https://rdrr.io/github/katiasmirn/PERFect/man/PERFect_perm.html) however as of this writing, I could not get this function to work. The process never finished :/

```{r}
# Set a pvalue cutoff
per_pval <- 0.1
```

```{r, code_folding=TRUE}
for (i in samp_ps_filt) {
  tmp_get <- get(purrr::map_chr(i, ~ paste0(., "_perfect")))
  tmp_get_ord <- get(purrr::map_chr(i, ~ paste0(., "_ord_perfect")))
  tmp_sim <- PERFect_sim(X = tmp_get, alpha = per_pval, Order = "NP", center = FALSE)
  dim(tmp_sim$filtX)
  tmp_sim_ord <- PERFect_sim(X = tmp_get_ord, alpha = per_pval, Order = "NP", center = FALSE)
  dim(tmp_sim_ord$filtX)
  
  tmp_sim_name <- purrr::map_chr(i, ~ paste0(., "_perfect_sim"))
  assign(tmp_sim_name, tmp_sim)

  tmp_sim_ord_name <- purrr::map_chr(i, ~ paste0(., "_ord_perfect_sim"))
  assign(tmp_sim_ord_name, tmp_sim_ord)
  
  tmp_path <- file.path("files/perfect/rdata/")
  saveRDS(tmp_sim, paste(tmp_path, tmp_sim_name, ".rds", sep = ""))
  saveRDS(tmp_sim_ord, paste(tmp_path, tmp_sim_ord_name, ".rds", sep = ""))

  rm(list = ls(pattern = "tmp_"))
  
}
its18_ps_work_ord_perfect_sim
objects(pattern = "_sim")
```


```{r, echo=FALSE}
## FOR TESTING
dim(its18_ps_work_perfect_sim$filtX)
dim(its18_ps_work_ord_perfect_sim$filtX)
dim(its18_ps_work_otu_perfect_sim$filtX)
dim(its18_ps_work_otu_ord_perfect_sim$filtX)

###########
tmp_obj <- its18_ps_work_ord_perfect_sim
tmp_ps <- its18_ps_work
###########
tmp_filt <- data.frame(t(tmp_obj$filtX))
tmp_filt <- tmp_filt %>% tibble::rownames_to_column("ID")
tmp_pval <- data.frame(tmp_obj$pvals)
tmp_pval <- tmp_pval %>% tibble::rownames_to_column("ID")
tmp_org <- data.frame(t(otu_table(tmp_ps)))
tmp_org <- tmp_org %>% tibble::rownames_to_column("ID")
tmp_com <- dplyr::left_join(tmp_pval, tmp_org, by = "ID") %>%
           dplyr::left_join(., tmp_filt, by = "ID")
write.table(tmp_com, "tmp_com.txt", quote = FALSE, sep = "\t", row.names = FALSE)
tmp_com
```


```{r, echo=FALSE}
ps_sim <- c("its18_ps_work_perfect_sim", "its18_ps_work_ord_perfect_sim", 
            "its18_ps_work_otu_perfect_sim", "its18_ps_work_otu_ord_perfect_sim")
for (i in ps_sim) {
  tmp_get <- get(i)
  tmp_name <- i
  tmp_get$info <- NULL
  tmp_get$DFL <- NULL
  tmp_get$est <- NULL
  tmp_get$fit <- NULL
  tmp_get$hist <- NULL
  tmp_get$pDFL <- NULL
  assign(tmp_name, tmp_get)
  rm(list = ls(pattern = "tmp_"))
}  
```

Now let's take a look at how many ASVs/OTUs were retained. 

First the ASV data set. Default ordering resulted in 
`r dim(its18_ps_work_perfect_sim$filtX)[2]` ASVs 
and reordering the data resulted in 
`r dim(its18_ps_work_ord_perfect_sim$filtX)[2]` ASVs.

And the OTU data set. Default ordering resulted in 
`r dim(its18_ps_work_otu_perfect_sim$filtX)[2]` OTUs 
and reordering the data resulted in 
`r dim(its18_ps_work_otu_ord_perfect_sim$filtX)[2]` OTUs.

For some reason, the package does not remove based on the p value cutoff that we set earlier (`r per_pval`). So we need to filter out the ASVs/OTUs that have a higher p value than the cutoff.

```{r echo=FALSE, results='hold', eval=TRUE}
cat("Total ASVs with p value less than", per_pval[1], "\n")
tmp_df <- its18_ps_work_perfect_sim$pvals
tmp_df <- data.frame(tmp_df)
pval_asv <- tmp_df %>% dplyr::summarise(count = sum(tmp_df <= per_pval))
print(paste("default order: ASVs before checking p value was", dim(its18_ps_work_perfect_sim$filtX)[2], "and after was", pval_asv$count[1]))

tmp_df <- its18_ps_work_ord_perfect_sim$pvals
tmp_df <- data.frame(tmp_df)
pval_asv_ord <- tmp_df %>% dplyr::summarise(count = sum(tmp_df <= per_pval))
print(paste("decreasing order: ASVs before checking p value was", dim(its18_ps_work_ord_perfect_sim$filtX)[2], "and after was", pval_asv_ord$count[1]))

print("-------------------")

cat("Total OTUs with p value less than", per_pval[1], "\n")
tmp_df <- its18_ps_work_otu_perfect_sim$pvals
tmp_df <- data.frame(tmp_df)
pval_otu <- tmp_df %>% dplyr::summarise(count = sum(tmp_df <= per_pval))
print(paste("default order: OTUs before checking p value was", dim(its18_ps_work_otu_perfect_sim$filtX)[2], "and after was", pval_otu$count[1]))
############
tmp_df <- its18_ps_work_otu_ord_perfect_sim$pvals
tmp_df <- data.frame(tmp_df)
pval_otu_ord <- tmp_df %>% dplyr::summarise(count = sum(tmp_df <= per_pval))
print(paste("decreasing order: OTUs before checking p value was", dim(its18_ps_work_otu_ord_perfect_sim$filtX)[2], "and after was", pval_otu_ord$count[1]))
```

Now we can make phyloseq objects. Manual inspection of the results from `PERFect_sim` indicated that using the default order and filtering p values < `r per_pval` resulted in the best results. This approach limited the number of ASVs/OTUs found in only 1 or 2 samples.

So first we filter out ASVs/OTUs with p values < `r per_pval` and then make the objects.

```{r, code_folding=TRUE}
for (i in samp_ps_filt) {
    tmp_get <- get(purrr::map_chr(i, ~ paste0(., "_perfect")))
    tmp_get_sim <- get(purrr::map_chr(i, ~ paste0(., "_perfect_sim")))
    tmp_filt <- data.frame(t(tmp_get_sim$filtX))
    tmp_filt <- tmp_filt %>% tibble::rownames_to_column("ID")
    tmp_tab <- data.frame(t(tmp_get))
    tmp_tab <- tmp_tab %>% tibble::rownames_to_column("ID")
    tmp_pvals <- data.frame(tmp_get_sim$pvals)
    tmp_pvals <- tmp_pvals %>% tibble::rownames_to_column("ID") %>% 
              dplyr::rename("pval" = 2)
    tmp_pvals <- tmp_pvals %>% filter(pval <= 0.1)
    tmp_merge <- dplyr::left_join(tmp_pvals, tmp_tab, by = "ID")
    tmp_merge[, 2] <- NULL
    tmp_merge <- tmp_merge %>% tibble::column_to_rownames("ID")
    tmp_tax <- data.frame(tax_table(get(i))) %>% tibble::rownames_to_column("ID")
    tmp_tax <- dplyr::left_join(tmp_pvals, tmp_tax, by = "ID")
    tmp_tax[, 2] <- NULL
    tmp_tax <- tmp_tax %>% tibble::column_to_rownames("ID")
# Build PS object
    tmp_samp <- data.frame(sample_data(get(i)))
    identical(row.names(tmp_tax), row.names(tmp_merge))
    tmp_merge <- data.frame(t(tmp_merge))
    tmp_merge <- as.matrix(tmp_merge)
    tmp_tax <- as.matrix(tmp_tax)
    tmp_ps <- phyloseq(otu_table(tmp_merge, taxa_are_rows = FALSE),
                     tax_table(tmp_tax),
                     sample_data(tmp_samp))
    
    #tmp_tree <- rtree(ntaxa(tmp_ps), rooted = TRUE,
    #                       tip.label = taxa_names(tmp_ps))
    tmp_ps <- merge_phyloseq(tmp_ps,
                               sample_data)
    tmp_ps_name <- purrr::map_chr(i, ~ paste0(., "_perf_filt"))
    assign(tmp_ps_name, tmp_ps)
    rm(list = ls(pattern = "tmp_"))
}  
objects()
objects(pattern = "_filt")
its18_ps_work_otu_perf_filt
```

```{r, eval=TRUE}
print("ASV phyloseq object")
its18_ps_work_perf_filt
print("OTU phyloseq object")
its18_ps_work_otu_perf_filt
```

Now let's take a look at how many reads and ASVs/OTUs were removed.

```{r, echo=FALSE, eval=TRUE, warning=FALSE}
tmp_objects <- data.frame(c("FULL data set", "PERFect filtered data", 
                            "FULL data set", "PERFect filtered data"))
tmp_samples <- c("its18_ps_work", "its18_ps_work_perf_filt", 
                 "its18_ps_work_otu", "its18_ps_work_otu_perf_filt")
tmp_type <- c("ASV", "ASV", "OTU", "OTU")
tmp_no_samp <- c()
for (i in tmp_samples) {
   tmp_get <- nsamples(get(i))
   tmp_no_samp <- c(append(tmp_no_samp, tmp_get))
}
tmp_no_samp <- data.frame(tmp_no_samp)

tmp_rc <- c()
for (i in tmp_samples) {
   tmp_get <- sum(readcount(get(i)))
   tmp_rc <- c(append(tmp_rc, tmp_get))
}
tmp_rc <- data.frame(tmp_rc)

tmp_asv <- c()
for (i in tmp_samples) {
   tmp_get <- ntaxa(get(i))
   tmp_asv <- c(append(tmp_asv, tmp_get))
}
tmp_asv <- data.frame(tmp_asv)

its18_perfect_sum <- dplyr::bind_cols(tmp_objects, tmp_type) %>%
                         dplyr::bind_cols(., tmp_no_samp) %>%
                         dplyr::bind_cols(., tmp_rc) %>%
                         dplyr::bind_cols(., tmp_asv) %>%
  dplyr::rename("Description" = 1, "type" = 2, "no. samples" = 3,
                "total reads" = 4, "total asvs" = 5)
rm(list = ls(pattern = "tmp_"))
```

<br/>

```{r, echo=FALSE, layout="l-body", eval=TRUE}
knitr::kable(its18_perfect_sum)
```

</br>

And finally save the phyloseq PERfect objects.

```{r, code_folding=TRUE}
its18_ps_perfect <- its18_ps_work_perf_filt
saveRDS(its18_ps_perfect, "files/perfect/rdata/its18_ps_perfect.rds")
its18_ps_perfect_otu <- its18_ps_work_otu_perf_filt
saveRDS(its18_ps_perfect_otu, "files/perfect/rdata/its18_ps_perfect_otu.rds")
```

```{r, echo=FALSE}
its18_perf_preval.tax <- tax_table(its18_ps_perfect)
write.table(its18_perf_preval.tax,
            file="files/perfect/tables/its18_asv_PERFECT_tax_table.txt",
            sep = "\t", quote = FALSE)

its18_perf_preval.asv <- otu_table(t(its18_ps_perfect))
write.table(its18_perf_preval.asv,
            file="files/perfect/tables/its18_asv_PERFECT_otu_table.txt",
            sep = "\t", quote = FALSE)

its18_perf_preval.samp <- sample_data(its18_ps_perfect)
write.table(its18_perf_preval.samp,
            file="files/perfect/tables/its18_asv_PERFECT_sample_data.txt",
            sep = "\t", quote = FALSE)
```

## Create Ampvis2 PERfect Objects

```{r, code_folding=TRUE}
ps_filt_obj <- c("its18_ps_perfect", "its18_ps_perfect_otu")
for (i in ps_filt_obj) {
    tmp_get <- get(i)
    tmp_otu <- data.frame(t(otu_table(tmp_get)))
    tmp_otu[] <- lapply(tmp_otu, as.numeric)
    tmp_otu <- as.matrix(tmp_otu)
    tmp_tax <- as.matrix(data.frame(tax_table(tmp_get)))
    tmp_samples <- data.frame(sample_data(tmp_get))
    tmp_ps_amp <- merge_phyloseq(otu_table(tmp_otu, taxa_are_rows = TRUE),
                          tax_table(tmp_tax),
                          sample_data(tmp_samples))
    tmp_ps_name <- purrr::map_chr(i, ~ paste0(., "_prep"))
    assign(tmp_ps_name, tmp_ps_amp)
    rm(list = ls(pattern = "tmp_"))
}
objects(pattern = "_prep")
```

```{r, code_folding=TRUE}
for (i in ps_filt_obj) {
  tmp_ps <- get(purrr::map_chr(i, ~ paste0(., "_prep")))
  tmp_amp_asv  <- data.frame(otu_table(tmp_ps))
  tmp_amp_asv <- tmp_amp_asv %>% tibble::rownames_to_column("OTU")
  tmp_amp_tax  <- data.frame(tax_table(tmp_ps))
  tmp_amp_tax <- tmp_amp_tax %>% tibble::rownames_to_column("OTU")
  tmp_amp_tax[8:ncol(tmp_amp_tax)] <- NULL
  tmp_amp_tax$Species <- tmp_amp_tax$OTU
  tmp_amp_asv_tax_perfect <- left_join(tmp_amp_asv, tmp_amp_tax, by = "OTU")
  tmp_samp_data_t <- data.frame(sample_data(tmp_ps))
  tmp_amp_data_perfect <- amp_load(tmp_amp_asv_tax_perfect, metadata = tmp_samp_data_t)

  tmp_otu_tax_name <- purrr::map_chr(i, ~ paste0(., "_amp_otutax_tab"))
  assign(tmp_otu_tax_name, tmp_amp_asv_tax_perfect)

  tmp_ps_name <- purrr::map_chr(i, ~ paste0(., "_amp"))
  assign(tmp_ps_name, tmp_amp_data_perfect)
  rm(list = ls(pattern = "tmp_"))
}  
objects(pattern = "_amp")
objects()
```

## Summary

```{r, code_folding=TRUE}
tmp_diversity_perfect <- amp_alphadiv(its18_ps_perfect_amp,
                                     measure = "observed", richness = FALSE)

tmp_diversity_perfect <- tmp_diversity_perfect %>% 
  dplyr::rename("total_reads" = "Reads", "total_asvs" = "ObservedOTUs")

tmp_diversity_perfect <- tmp_diversity_perfect[order(tmp_diversity_perfect$SamName), ]
its18_ps_perfect_amp <- amp_load(its18_ps_perfect_amp_otutax_tab,
                          metadata = tmp_diversity_perfect)
rm(tmp_diversity_perfect)

tmp_diversity_perfect <- amp_alphadiv(its18_ps_perfect_otu_amp, 
                                     measure = "observed", richness = FALSE)

tmp_diversity_perfect <- tmp_diversity_perfect %>% 
  dplyr::rename("total_reads" = "Reads", "total_asvs" = "ObservedOTUs")

tmp_diversity_perfect <- tmp_diversity_perfect[order(tmp_diversity_perfect$SamName), ]
its18_ps_perfect_otu_amp <- amp_load(its18_ps_perfect_otu_amp_otutax_tab,
                                     metadata = tmp_diversity_perfect)
```


```{r, code_folding=TRUE}
its18_amp_perfect <- its18_ps_perfect_amp
rm(its18_ps_perfect_amp)
saveRDS(its18_amp_perfect, "files/perfect/rdata/its18_amp_perfect.rds")
its18_amp_perfect_otu <- its18_ps_perfect_otu_amp
rm(its18_ps_perfect_otu_amp)
saveRDS(its18_amp_perfect_otu, "files/perfect/rdata/its18_amp_perfect_otu.rds")
objects()
```

Let's take a look at a table of sample information. Any header with the `_p` suffix is the *PERfect filtered* data.

<br/>

```{r, echo=FALSE}
## This is for table only
its18_dummy_tab <- its18_amp_perfect$metadata
its18_dummy_tab <- its18_dummy_tab %>%
  dplyr::rename("total_reads_p" = "total_reads") %>%
  dplyr::rename("total_asvs_p" = "total_asvs")
```

```{r, echo=FALSE, layout="l-body-outset", eval=TRUE}
## elementId https://www.random.org/strings/
its18_samp_data_tab_2 <- its18_dummy_tab

datatable(its18_samp_data_tab_2, width = "100%", escape = FALSE,
          rownames = FALSE, filter = 'top',
          caption = htmltools::tags$caption(
            style = 'caption-side: bottom; text-align: left;',
            'Table: ', htmltools::em('Sample summary table.
            Use the buttons to navigate through the table or
            download a copy.')),
          elementId = "k9rn0xxltiqkg0bowglj",
          extensions = 'Buttons', options = list(
            scrollX = TRUE,
            dom = 'Blfrtip',
            buttons = c('copy', 'csv', 'excel'),
            pageLength = 5,
            lengthMenu = c(5, 15)
            )
          ) %>%
    DT::formatStyle(columns = colnames(its18_samp_data_tab_2),
                    fontSize = '80%')
```

```{r, echo=FALSE}
save.image("page_build/perfect_its18_wf.rdata")
```

```{r, echo=FALSE, eval=TRUE}
remove(list = ls())
```

##  Source Code {.appendix}

The source code for this page can be accessed on GitHub by [clicking this link](https://github.com/sweltr/high-temp/blob/master/perfect.Rmd). Please note, that in order to process the data *and*  build the website, we needed to run the workflow and get the results. Then hard code the results and turn off the individual commands. So the raw file for this page is a bit messy---you have been warned.
